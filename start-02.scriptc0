import "механоид/механоид.scriptc0" type Механоид;
import "механоид/пушка.scriptc0" type Пушка;
import "механоид/параметры_системы.scriptc0" type Параметры параметры;
import "механоид/враги.scriptc0" type Враги;
import "механоид/элемент.scriptc0" type Элемент;

auto точки_высадки = [
            { x: 90.0, y : 20.0, z : 0.0 },
            { x: -90.0, y : 20.0, z : 0.0 },
            { x: 0.0, y : 20.0, z : 90.0 },
            { x: 0.0, y : 20.0, z : -90.0 },
          ];
// Поле сцены
auto поле = [   { x: 150.0, y : 1.0, z : 150.0 },
                { x: -150.0, y : 0.0, z : 150.0 },
                { x: -150.0, y : 0.0, z : -150.0 },
                { x: 150.0, y : 0.0, z : -150.0 },
            ];
        
Механоид образец;
Механоид м[4] = [образец, образец, образец, образец];
int количество_механоидов = 4;

// Массив элементов, которые механоид видит
Элемент видимые_элементы[количество_механоидов + параметры.количество_флагов];
Элемент элемент;
int количество_видимых_элементов = 0;

for(int i=0; i < количество_механоидов; ++i) {
    // Для каждого механоида:
    // - устанавливаем точку высадки
    м[i].д.y1 = точки_высадки[i].x;
    м[i].д.y3 = точки_высадки[i].z;
    м[i].д.xc = параметры.флаг[0].x;
    м[i].д.zc = параметры.флаг[0].z;
    м[i].д.V_z = параметры.скорость_ходьбы;
    // - доп
    м[i].радиус_зрения = math.random_float(40.0, 60.0);
    м[i].задержка_в_приседании = math.random_float(2.0, 5.0);
    // - определяем экипировку
    м[i].fillEquip();
}

float Rtarget = 1.0;

auto Режим = { Высадка : 0, Бой : 1};
int режим = Режим.Бой;
//Чтобы добавить несколько флагов и по очереди к ним идти
int захваченные_флаги[параметры.количество_флагов];
int количество_захваченных_флагов = 0;
// Инициализация графиков
chart.init("Сцена");
// graph3d.init("Сцена");

mechanoid.init("_");
mechanoid.addSeries("Ф" + количество_захваченных_флагов, 1);
mechanoid.addPoint("Ф" + количество_захваченных_флагов, 
                    параметры.флаг[количество_захваченных_флагов].x,
                    параметры.флаг[количество_захваченных_флагов].z );
mechanoid.addSeries("П", 2);
mechanoid.addPoint("П", поле[0].x, поле[0].z);
mechanoid.addPoint("П", поле[1].x, поле[1].z);
mechanoid.addPoint("П", поле[2].x, поле[2].z);
mechanoid.addPoint("П", поле[3].x, поле[3].z);

mechanoid.addSeries("М"+0, 1);
mechanoid.addSeries("М"+1, 1);
mechanoid.addSeries("М"+2, 1);
mechanoid.addSeries("М"+3, 1);

for(int i=0; i < количество_механоидов; ++i) {
    mechanoid.setPointsCount("М"+i,1);
}

for(int i=0; i < количество_механоидов; ++i) {
   for(int j=0; j < 100; ++j) {
    mechanoid.addSeries("Ракета " + i + " " + j, 0);
    mechanoid.setPointsCount("Ракета " + i + " " + j, 1);
    }
}

// Запсукает снаряд пушки из обоймы
void rocketLaunch(int i, float xj, float zj) {
    м[i].пушка.количество_зарядов -= 1;
    int j = 0; 
    j = м[i].пушка.количество_зарядов;
    
    // Установка начальныtell me, tell me, tell me you, want me, want me, want me tooх координат ракеты
    м[i].пушка.обойма[j].ракета.y1 = м[i].д.y1;
    м[i].пушка.обойма[j].ракета.y2 = м[i].д.y2;
    м[i].пушка.обойма[j].ракета.y3 = м[i].д.y3;

    // Установка конечных координат ракеты
    м[i].пушка.обойма[j].ракета.xc = xj;
    м[i].пушка.обойма[j].ракета.zc = zj;
    м[i].пушка.обойма[j].ракета.V_z = образец.параметры.скорость_выстрела;
    scene.add(м[i].пушка.обойма[j].ракета);
}

// Проверка, что ракета внутри поля
void rocketOnScene(int i, int j) {
    j = j;
    if (((м[i].пушка.обойма[j].ракета.y1 > -150.0) && (м[i].пушка.обойма[j].ракета.y1 < 150.0)) &&
       ((м[i].пушка.обойма[j].ракета.y2 > 0.0) && (м[i].пушка.обойма[j].ракета.y2 < 1.0)) &&
       ((м[i].пушка.обойма[j].ракета.y3 > -150.0) && (м[i].пушка.обойма[j].ракета.y3 < 150.0)))
       {}
    else {
        м[i].пушка.обойма[j].отобржать = false;
        scene.remove(м[i].пушка.обойма[j].ракета);
        mechanoid.removeSeries("Ракета " + i + " " + j);
    }
}

// Проверка попадания ракеты
void rocketHit(int cur) {
    if (м[cur].пушка.количество_зарядов != м[cur].пушка.макс_колво_зарядов) {
        for(int i = м[cur].пушка.макс_колво_зарядов - 1; i >= м[cur].пушка.количество_зарядов; --i) {
            if (м[cur].пушка.обойма[i].отобржать == true) {
                for (int j = 0; j < количество_механоидов; ++j) {
                    if (j != cur) {
                        // sys.print(math.sqrt((м[j].д.y1-м[cur].пушка.обойма[i].ракета.y1)^2 + (м[j].д.y3-м[cur].пушка.обойма[i].ракета.y3)^2));
                        if (math.sqrt((м[j].д.y1-м[cur].пушка.обойма[i].ракета.y1)^2 + (м[j].д.y3-м[cur].пушка.обойма[i].ракета.y3)^2) <= 8.5) {
                         // math.sqrt((образец.параметры.флаг[1].x-м[i].д.y1)^2 + (образец.параметры.флаг[1].z-м[i].д.y3)^2) < Rtarget
                            м[j].здоровье -= 10;
                            sys.print("Механоид " + cur + " попал в механоида " + j + " оставшееся здоровье " + м[j].здоровье + " Время: "+scene.t()+" c " + math.sqrt((м[j].д.y1-м[cur].пушка.обойма[i].ракета.y1)^2 + (м[j].д.y3-м[cur].пушка.обойма[i].ракета.y3)^2));
                            м[cur].пушка.обойма[i].отобржать = false;
                            mechanoid.removeSeries("Ракета " + cur + " " + i);
                        }
                    }
                }
            }
        }
    }
}

// Определение функции обратного вызова (callback) для отображения результатов моделирования
void onShow() {
//    chart.addPoint( "0", scene.t(), 0.0);
//    graph3d.addPint oint("М"+1, м[1].д.y1, м[1].д.y2, м[1].д.y3);
    for(int i=0; i < количество_механоидов; ++i) {
//        chart.addPoint( "nxt"+i, scene.t(), м[i].д.nxt);
        chart.addPoint( "P"+i, scene.t(), м[i].д.P);
//        chart.addPoint( "Vg"+i, scene.t(), м[i].д.Vg);
//        chart.addPoint( "y5"+i, scene.t(), м[i].д.y5);
//        chart.addPoint( "y2"+i, scene.t(), м[i].д.y2);
        chart.addPoint( "X"+i, scene.t(), м[i].д.X);
//        chart.addPoint( "R"+i, scene.t(),
//                       math.sqrt((образец.параметры.флаг.x-м[i].д.y1)^2 
//                        + (образец.параметры.флаг.z-м[i].д.y3)^2));
        
        mechanoid.addPoint("М"+i, м[i].д.y1, м[i].д.y3);
        
        if (м[i].пушка.количество_зарядов != м[i].пушка.макс_колво_зарядов) {
            for(int j = м[i].пушка.макс_колво_зарядов - 1; j >= м[i].пушка.количество_зарядов; --j) {
                if (м[i].пушка.обойма[j].отобржать == true) {
                    mechanoid.addPoint("Ракета " + i + " " + j, м[i].пушка.обойма[j].ракета.y1, м[i].пушка.обойма[j].ракета.y3);
                    rocketOnScene(i, j);
                }
            }
        }
    }
}

// Работа датчика зрения механоида
void vision(int cur) {
    количество_видимых_элементов = 0;
    // Проверяем механоиды
    for(int i=0; i < количество_механоидов; ++i) {
        if ((math.sqrt((м[i].д.y1 - м[cur].д.y1)^2 + (м[i].д.y3 - м[cur].д.y3)^2) <= м[cur].радиус_зрения) && (cur != i)) {
        // sys.print("Механоид " + cur + " увидел механоида " + i + "  Время: "+scene.t()+" c" );
        // видимые_элементы[количество_видимых_элементов] = элемент;
        видимые_элементы[количество_видимых_элементов].индекс = i;
        видимые_элементы[количество_видимых_элементов].тип_элемента = "Механоид";
        ++количество_видимых_элементов;
        }
    }
    
    // Проверяем флаги
    for(int i=0; i < параметры.количество_флагов; ++i) {
        for(int j=0; j < количество_захваченных_флагов; ++j) {
            if (i != захваченные_флаги[j]) {
                if ((math.sqrt((параметры.флаг[i].x - м[cur].д.y1)^2 + (параметры.флаг[i].z - м[cur].д.y3)^2) <= м[cur].радиус_зрения)) {
                // sys.print("Механоид " + cur + " увидел флаг " + (i + 1) + "  Время: "+scene.t()+" c" );
                // видимые_элементы[количество_видимых_элементов] = элемент;
                видимые_элементы[количество_видимых_элементов].индекс = i;
                видимые_элементы[количество_видимых_элементов].тип_элемента = "Флаг";
                 ++количество_видимых_элементов;
                }
            }
        }
        if (количество_захваченных_флагов == 0) {
            if ((math.sqrt((параметры.флаг[i].x - м[cur].д.y1)^2 + (параметры.флаг[i].z - м[cur].д.y3)^2) <= м[cur].радиус_зрения)) {
            // sys.print("Механоид " + cur + " увидел флаг " + (i + 1) + "  Время: "+scene.t()+" c" );
            // видимые_элементы[количество_видимых_элементов] = элемент;
            видимые_элементы[количество_видимых_элементов].индекс = i;
            видимые_элементы[количество_видимых_элементов].тип_элемента = "Флаг";
            ++количество_видимых_элементов;
            }
        }
    }
    
    // Проверяем элементы
}

// Проверка достижения флага
void flag_catch(int i) {
    if ((количество_захваченных_флагов < параметры.количество_флагов) && math.sqrt((параметры.флаг[количество_захваченных_флагов].x-м[i].д.y1)^2 + (параметры.флаг[количество_захваченных_флагов].z - м[i].д.y3)^2) < Rtarget) {
        sys.print("Механоид " + i + " захватил флаг " + количество_захваченных_флагов + "! Время: " + scene.t() + " c" );
        захваченные_флаги[количество_захваченных_флагов] = количество_захваченных_флагов;
        mechanoid.removeSeries("Ф " + количество_захваченных_флагов);
        количество_захваченных_флагов += 1;
        if (количество_захваченных_флагов < параметры.количество_флагов) {
            mechanoid.addSeries("Ф" + количество_захваченных_флагов, 1);
            mechanoid.addPoint("Ф" + количество_захваченных_флагов,
                образец.параметры.флаг[количество_захваченных_флагов].x,
                образец.параметры.флаг[количество_захваченных_флагов].z);
        }
    }
}

// Движение, когда у механоида нет цели
void default_movement(int i, float длина_стороны, bool reset) {
    if(reset) {
        м[i].вершина.x = м[i].д.y1;
        м[i].вершина.z = м[i].д.y3;
        м[i].состояние = 0;
    }

    if(м[i].состояние == 0) {
        if (math.sqrt((м[i].вершина.x-м[i].д.y1)^2 + (м[i].вершина.z-м[i].д.y3)^2) >= длина_стороны)
        {
            м[i].состояние = 1;
            м[i].вершина.x = м[i].д.y1;
            м[i].вершина.z = м[i].д.y3;
        }
        м[i].д.xc = м[i].вершина.x + длина_стороны;
        м[i].д.zc = м[i].вершина.z;
    }
    if(м[i].состояние == 1) {
        if (math.sqrt((м[i].вершина.x-м[i].д.y1)^2 + (м[i].вершина.z-м[i].д.y3)^2) >= длина_стороны)
        {
            м[i].состояние = 2;
            м[i].вершина.x = м[i].д.y1;
            м[i].вершина.z = м[i].д.y3;
        }
        м[i].д.xc = м[i].вершина.x;
        м[i].д.zc = м[i].вершина.z - длина_стороны;
    }
       
    if(м[i].состояние == 2) {
        if (math.sqrt((м[i].вершина.x-м[i].д.y1)^2 + (м[i].вершина.z-м[i].д.y3)^2) >= длина_стороны)
        {
            м[i].состояние = 3;
            м[i].вершина.x = м[i].д.y1;
            м[i].вершина.z = м[i].д.y3;
        }
        м[i].д.xc = м[i].вершина.x - длина_стороны;
        м[i].д.zc = м[i].вершина.z;
    }
    if(м[i].состояние == 3) {
        if (math.sqrt((м[i].вершина.x-м[i].д.y1)^2 + (м[i].вершина.z-м[i].д.y3)^2) >= длина_стороны)
        {
            м[i].состояние = 0;
            м[i].вершина.x = м[i].д.y1;
            м[i].вершина.z = м[i].д.y3;
        }
        м[i].д.xc = м[i].вершина.x;
        м[i].д.zc = м[i].вершина.z + длина_стороны;
    }
}

// Движение, когда у механоида есть цель
void target_movement(int i,  float x, float z) {
    м[i].д.xc = x;
    м[i].д.zc = z;
}

void onIteration() {
    for(int i=0; i < количество_механоидов; ++i) {
        rocketHit(i);
        vision(i);
        // flag_catch(i);
        if (количество_видимых_элементов != 0) {
            for(int j=0; j < количество_видимых_элементов; ++j) {
                if (видимые_элементы[j].тип_элемента == "Механоид") {
                    if (м[i].пушка.количество_зарядов != 0) {
                        // м[i].д.V_z = 0.5;
                        if ((scene.t() - м[i].пушка.flag) > 1.0) {
                        // sys.print("Механоид " + i + " Количество зарядов : " + м[i].пушка.количество_зарядов +  " Время: "+scene.t()+" c" );
                        rocketLaunch(i, м[j].д.y1, м[j].д.y3);
                        target_movement(i, м[j].д.y1, м[j].д.y3);
                        м[i].пушка.flag = scene.t();
                        }
                    }
                }
                
                if (видимые_элементы[j].тип_элемента == "Флаг") {
                    target_movement(i, параметры.флаг[видимые_элементы[j].индекс].x, параметры.флаг[видимые_элементы[j].индекс].z);
                    sys.print("Механоид " + i + " увидел флаг " + видимые_элементы[j].индекс + "  Время: " + scene.t() + " c" );
                    flag_catch(i);
                }
            }
        }
        else {
            default_movement(i, 25.0, false);
        }
        
      /*
       Враги в;  
       for(int j=0; j < количество_механоидов; ++j) {
            if (j != i) {
                if (math.sqrt((м[j].д.y1-м[i].д.y1)^2 + (м[j].д.y3-м[i].д.y3)^2)
                    < м[i].радиус_зрения) {
                    в.поз[j].задана = true;
                    в.поз[j].x = м[j].д.y1;
                    в.поз[j].y = м[j].д.y2;
                    в.поз[j].z = м[j].д.y3;
                     
                         М0 = Sphere
                         М1 = Cylinder
                         М2 = Cube
                         М3 = Minimal (Тетраэдр) 
                         
                    // м[i].д.V_z = 0;
                    sys.print("Механоид " + i + " увидел врага! " + j + "  Время: "+scene.t()+" c" );
                    
                    if (м[i].пушка.количество_зарядов != 0)
                    {
                        if ((scene.t() - м[i].пушка.flag) > 1.0) {
                        rocketLaunch(i, м[i].д.y1, м[i].д.y2, м[i].д.y3, м[j].д.y1, м[j].д.y3);
                        м[i].пушка.flag = scene.t();
                        }
                    }
                }
        
        м[i].control(в); */
        
    }
}

// Инициализация сцены
scene.setIterationCallback(onShow, 10);
scene.setEachIterationCallback(onIteration);
scene.setRealtimeModeEnabled(true); 
scene.setT(0.0);
scene.setDt(0.01);
scene.setTk(3000.0);
// Добавление объектов на сцену
for(int i=0; i < количество_механоидов; ++i) {    
    scene.add(м[i].д);
    // scene.add(rockets[i].ракета);
}
// Запуск моделирования
scene.start();

