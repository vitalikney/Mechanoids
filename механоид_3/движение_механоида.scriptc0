import "параметры_изм.scriptc0" type Параметры параметры;
import "параметры_неизм.scriptc0" type Константы константы;
import "механоид.scriptc0" type Механоид;

float sceneT() {
}

// Движение, когда у механоида нет цели. Движение по квадрату
void defaultMovement(Механоид м, float длина_стороны, bool reset) {
    if(reset) {
        м.вершина.x = м.д.y1;
        м.вершина.z = м.д.y3;
        м.состояние = 0;
    }

    if(м.состояние == 0) {
        if (((м.вершина.x-м.д.y1)^2 + (м.вершина.z-м.д.y3)^2) >= длина_стороны * длина_стороны) {
            м.состояние = 1;
            м.вершина.x = м.д.y1;
            м.вершина.z = м.д.y3;
        }
        м.д.xc = м.вершина.x + длина_стороны;
        м.д.zc = м.вершина.z;
    }
    if(м.состояние == 1) {
        if (((м.вершина.x-м.д.y1)^2 + (м.вершина.z-м.д.y3)^2) >= длина_стороны * длина_стороны) {
            м.состояние = 2;
            м.вершина.x = м.д.y1;
            м.вершина.z = м.д.y3;
        }
        м.д.xc = м.вершина.x;
        м.д.zc = м.вершина.z - длина_стороны;
    }
       
    if(м.состояние == 2) {
        if (((м.вершина.x-м.д.y1)^2 + (м.вершина.z-м.д.y3)^2) >= длина_стороны * длина_стороны) {
            м.состояние = 3;
            м.вершина.x = м.д.y1;
            м.вершина.z = м.д.y3;
        }
        м.д.xc = м.вершина.x - длина_стороны;
        м.д.zc = м.вершина.z;
    }
    if(м.состояние == 3) {
        if (((м.вершина.x-м.д.y1)^2 + (м.вершина.z-м.д.y3)^2) >= длина_стороны * длина_стороны) {
            м.состояние = 0;
            м.вершина.x = м.д.y1;
            м.вершина.z = м.д.y3;
        }
        м.д.xc = м.вершина.x;
        м.д.zc = м.вершина.z + длина_стороны;
    }
}

// Движение, когда у механоида нет цели. Движение по синусу
void defaultSinusMovement(Механоид м, float амплитуда, float дельта, int режим_синуса) {
    // режим_синуса = 0. Механоид движется вправо по x 
    if (режим_синуса == 0) {
        if ((math.abs(м.д.zc - м.д.y3) > (дельта + дельта / 10000)) || (math.vec2Len(м.д.zc - м.д.y3, м.д.xc - м.д.y1) == 0.0)) {
            м.д.zc = м.д.y3 - дельта;
            м.д.xc = амплитуда * math.sin(м.д.zc);
            sys.print("x, y: " + м.д.y3 + " " + м.д.y1 + " go to: " + м.д.zc + " " + м.д.xc);
        }
    }
    
    // режим_синуса = 1. Механоид движется влево по x
    if (режим_синуса == 1) {
        if ((math.abs(м.д.zc - м.д.y3) > (дельта + дельта / 10000)) || (math.vec2Len(м.д.zc - м.д.y3, м.д.xc - м.д.y1) <= 1.0)) {
            м.д.zc = м.д.y3 + дельта;
            м.д.xc = амплитуда * math.sin(м.д.zc);
        }
    }
    
    // режим_синуса = 2. Механоид движется вверх по y 
    if (режим_синуса == 2) {
        if ((math.abs(м.д.xc - м.д.y1) > (дельта + дельта / 10000)) || (math.vec2Len(м.д.zc - м.д.y3, м.д.xc - м.д.y1) <= 1.0)) {
            м.д.xc = м.д.y1 - дельта;
            м.д.zc = амплитуда * math.sin(м.д.xc);
        }
    }
    // режим_синуса = 3. Механоид движется вниз по y
    if (режим_синуса == 3) {
        if ((math.abs(м.д.xc - м.д.y1) > (дельта + дельта / 10000)) || (math.vec2Len(м.д.zc - м.д.y3, м.д.xc - м.д.y1) <= 1.0)) {
            м.д.xc = м.д.y1 + дельта;
            м.д.zc = амплитуда * math.sin(м.д.xc);
        }
    }
  
    // sys.print("x, y: " + м.д.y3 + " " + м.д.y1 + " go to: " + м.д.zc + " " + м.д.xc);
}

// Движение, когда у механоида есть цель
void targetMovement(Механоид м,  float x, float y) {
    м.д.xc = x;
    м.д.zc = y;
}